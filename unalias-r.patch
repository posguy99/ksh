diff --git a/src/cmd/ksh93/bltins/typeset.c b/src/cmd/ksh93/bltins/typeset.c
index 07a2d5695..486f24417 100644
--- a/src/cmd/ksh93/bltins/typeset.c
+++ b/src/cmd/ksh93/bltins/typeset.c
@@ -1286,7 +1286,7 @@ static int unall(int argc, char **argv, register Dt_t *troot)
 	register const char *name;
 	volatile int r;
 	Dt_t	*dp;
-	int nflag=0,all=0,isfun,jmpval,nofree_attr;
+	int nflag=0,all=0,isfun,jmpval;
 	struct checkpt buff;
 	NOT_USED(argc);
 	if(troot==sh.alias_tree)
@@ -1388,13 +1388,6 @@ static int unall(int argc, char **argv, register Dt_t *troot)
 					sh_assignok(np, !nv_isattr(np,NV_NODISC|NV_ARRAY) && !nv_isvtree(np));
 				}
 			}
-			/*
-			 * Preset aliases have the NV_NOFREE attribute and cannot be safely freed from memory.
-			 * _nv_unset discards this flag so it's obtained now to prevent an invalid free crash.
-			 */
-			if(troot==sh.alias_tree)
-				nofree_attr = nv_isattr(np,NV_NOFREE);	/* note: returns bitmask, not boolean */
-
 			if(!nv_isnull(np) || nv_size(np) || nv_isattr(np,~(NV_MINIMAL|NV_NOFREE)))
 				_nv_unset(np,0);
 			if(troot==sh.var_tree && sh.st.real_fun && (dp=sh.var_tree->walk) && dp==sh.st.real_fun->sdict)
@@ -1411,7 +1404,10 @@ static int unall(int argc, char **argv, register Dt_t *troot)
 			{
 				if(sh.subshell && !sh.subshare)
 					sh_subfork();	/* avoid affecting the parent shell's alias table */
-				nv_delete(np,troot,nofree_attr);
+				_nv_unset(np,NV_RDONLY|nv_isattr(np,NV_NOFREE));
+				dtdelete(troot,np);
+				if(!sh.bltin_aliases || np < sh.bltin_aliases || np > &sh.bltin_aliases[sh.bltin_num_aliases])
+					free(np);
 			}
 		}
 		else if(troot==sh.alias_tree)
diff --git a/src/cmd/ksh93/include/shell.h b/src/cmd/ksh93/include/shell.h
index 8ab90b835..cb7607959 100644
--- a/src/cmd/ksh93/include/shell.h
+++ b/src/cmd/ksh93/include/shell.h
@@ -251,6 +251,8 @@ struct Shell_s
 	pid_t		current_ppid;	/* PPID of current ksh process (updates when subshell forks) */
 	unsigned char	sigruntime[2];
 	Namval_t	*bltin_nodes;
+	Namval_t	*bltin_aliases;
+	int		bltin_num_aliases;
 	Namval_t	*bltin_cmds;
 	History_t	*hist_ptr;
 	char		*shpath;
diff --git a/src/cmd/ksh93/sh/init.c b/src/cmd/ksh93/sh/init.c
index aad6999b3..8d901ccd8 100644
--- a/src/cmd/ksh93/sh/init.c
+++ b/src/cmd/ksh93/sh/init.c
@@ -1627,9 +1627,10 @@ int sh_reinit(char *argv[])
 		if((dp = sh.alias_tree)->walk)
 			dp = dp->walk;
 		npnext = (Namval_t*)dtnext(sh.alias_tree,np);
-		nofree = nv_isattr(np,NV_NOFREE);			/* note: returns bitmask, not boolean */
-		_nv_unset(np,NV_RDONLY);				/* also clears NV_NOFREE attr, if any */
-		nv_delete(np,dp,nofree);
+		_nv_unset(np,NV_RDONLY|nv_isattr(np,NV_NOFREE));
+		dtdelete(sh.alias_tree,np);
+		if(!sh.bltin_aliases || np < sh.bltin_aliases || np > &sh.bltin_aliases[sh.bltin_num_aliases])
+			free(np);
 	}
 	/* Delete hash table entries */
 	for(np = dtfirst(sh.track_tree); np; np = npnext)
@@ -1966,6 +1967,11 @@ Dt_t *sh_inittree(const struct shtable2 *name_vals)
 		sh.bltin_nodes = np;
 		nvars = n;
 	}
+	else if(name_vals==shtab_aliases)
+	{
+		sh.bltin_aliases = np;
+		sh.bltin_num_aliases = n;
+	}
 	else if(name_vals==(const struct shtable2*)shtab_builtins)
 		sh.bltin_cmds = np;
 	base_treep = treep = dtopen(&_Nvdisc,Dtoset);
